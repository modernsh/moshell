use crate::disassemble::display_bytecode;
use crate::pipeline::RealFilesystem;
use crate::report::{error_to_diagnostic, MultiFile};
use analyzer::{Database, PipelineError, Reef};
use clap::Parser;
use clap_complete::Shell;
use cli::pipeline::PipelineStatus;
use compiler::{compile_reef, CompilerOptions};
use miette::Report;
use std::path::PathBuf;
use vm::{VmError, VM};

/// The Moshell scripting language.
#[derive(Parser)]
#[command(author, version, about, long_about = None)]
pub struct Cli {
    /// The inline source code to parse
    #[arg(short = 'c')]
    pub(crate) code: Option<String>,

    /// Defines the source file to parse
    #[arg(index = 1)]
    pub(crate) source: Option<PathBuf>,

    /// Prints the generated bytecode
    #[arg(short = 'D', long)]
    pub(crate) disassemble: bool,

    /// Display a textual representation of the abstract syntax tree
    #[arg(short = 'A', long)]
    pub(crate) ast: bool,

    /// Do not execute the code
    #[arg(long = "no-execute")]
    pub(crate) no_execute: bool,

    /// Generate tab-completion scripts for your shell
    #[arg(long = "completions")]
    pub(crate) completions: Option<Shell>,

    /// The arguments to pass to the script
    #[arg(index = 2)]
    pub(crate) program_arguments: Vec<String>,
}

#[must_use = "The pipeline status should be checked"]
pub fn use_pipeline(
    database: &Database,
    reef: &Reef,
    fs: &RealFilesystem,
    vm: &mut VM,
    errors: Vec<PipelineError>,
    config: &Cli,
) -> PipelineStatus {
    let mut status = PipelineStatus::Success;
    for error in errors {
        status = status.compose(match &error {
            PipelineError::Import { .. } => PipelineStatus::IoError,
            PipelineError::Parse { .. } | PipelineError::Type(_) => PipelineStatus::AnalysisError,
        });
        let mut multi_file = MultiFile::default();
        let diagnostic = error_to_diagnostic(error, &mut multi_file, fs);
        let report = Report::from(diagnostic).with_source_code(multi_file);
        eprintln!("{report:?}");
    }
    if status != PipelineStatus::Success {
        return status;
    }

    let mut bytes = Vec::new();
    compile_reef(
        database,
        reef,
        &mut bytes,
        CompilerOptions {
            line_provider: None,
            last_page_storage_var: None,
        },
    )
    .expect("write failed");

    if config.disassemble {
        display_bytecode(&bytes);
    }

    if !config.no_execute {
        vm.register(&bytes)
            .expect("compilation created invalid bytecode");
        drop(bytes);
        match unsafe { vm.run() } {
            Ok(()) => {}
            Err(VmError::Panic) => return PipelineStatus::ExecutionFailure,
            Err(VmError::Internal) => panic!("VM internal error"),
        }
    }
    status
}
