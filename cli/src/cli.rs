use std::collections::HashMap;
use std::io::stderr;
use std::path::PathBuf;

use clap::Parser;
use dbg_pls::color;

use crate::disassemble::display_bytecode;
use analyzer::importer::ASTImporter;
use analyzer::name::Name;
use analyzer::resolve_all;
use analyzer::steps::typing::apply_types;
use ast::group::Block;
use ast::Expr;
use compiler::compile;
use context::source::Source;
use parser::parse;

use crate::report::{display_diagnostic, display_parse_error};

#[derive(Parser)]
#[command(author, version, about, long_about = None)]
pub struct Cli {
    /// Defines the source file to parse
    #[arg(short, long, value_name = "FILE")]
    pub(crate) source: Option<PathBuf>,

    /// shows textual representation of generated bytecode
    #[arg(short = 'D', long)]
    pub(crate) disassemble: bool,

    /// shows textual representation of generated bytecode
    #[arg(short = 'A', long)]
    pub(crate) ast: bool,
}

#[derive(Default)]
struct RawImporter<'a> {
    imported_modules: HashMap<Name, Expr<'a>>,
}

impl<'a> ASTImporter<'a> for RawImporter<'a> {
    fn import(&mut self, name: &Name) -> Option<Expr<'a>> {
        self.imported_modules.get(name).cloned()
    }
}

/// Parses and display errors / diagnostics coming from the given source.
/// Returning true if the source had at least one error or diagnostic.
pub fn handle_source(config: &Cli, source: Source) -> bool {
    let report = parse(source);
    let mut importer = RawImporter::default();

    let errors: Vec<_> = report.errors;

    let out = &mut stderr();
    if !errors.is_empty() {
        for error in errors {
            display_parse_error(source, error, out).expect("IO error when reporting diagnostics");
        }
        return true;
    }

    if config.ast {
        println!("{}", color(&report.expr));
    }

    let expr = Expr::Block(Block {
        expressions: report.expr,
        segment: 0..0,
    });

    let name = Name::new("<module>");
    importer.imported_modules.insert(name.clone(), expr);

    let result = resolve_all(name, &mut importer);

    let mut diagnostics = result.diagnostics;
    if diagnostics.is_empty() {
        let (types, typing) = apply_types(&result.engine, &result.relations, &mut diagnostics);
        if diagnostics.is_empty() {
            let mut bytes = Vec::new();
            compile(&types, &result.engine, &typing, &mut bytes).expect("write failed");

            if config.disassemble {
                display_bytecode(&bytes);
            }

            execute(&bytes);

            return false;
        }
    }

    let mut stdout = stderr();
    let had_errors = !diagnostics.is_empty();
    for diagnostic in diagnostics {
        display_diagnostic(source, diagnostic, &mut stdout)
            .expect("IO errors when reporting diagnostic")
    }
    had_errors
}

#[link(name = "vm", kind = "static")]
extern "C" {
    /// Execute the given bytecode.
    ///
    /// # Safety
    /// If the given bytecode is invalid, this function will cause undefined behavior.
    fn moshell_exec(bytes: *const u8, byte_count: usize);
}

fn execute(bytes: &[u8]) {
    unsafe {
        moshell_exec(bytes.as_ptr(), bytes.len());
    }
}
