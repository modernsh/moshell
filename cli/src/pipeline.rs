use analyzer::{FileImporter, Filesystem};
use compiler::CompilerState;
use std::io;
use std::path::{Path, PathBuf};
use std::process::{ExitCode, Termination};
use vm::VM;

pub(crate) struct Pipeline {
    pub(crate) filesystem: REPLFilesystem,
    pub(crate) compiler_state: CompilerState,
    pub(crate) vm: VM,
}

/// Represents the state of the pipeline.
#[repr(u8)]
#[derive(PartialEq, Debug, Clone, Copy, Eq)]
pub enum PipelineStatus {
    /// All the steps of the pipeline were executed successfully.
    Success,

    /// The execution of the generated bytecode exited with an error.
    ExecutionFailure,

    /// The parsing or the verification of a source failed.
    AnalysisError,

    /// A source could not be read because of an IO error.
    IoError,
}

impl PipelineStatus {
    /// Composes two statuses, by propagating error statuses.
    pub fn compose(self, other: Self) -> Self {
        match (self, other) {
            (Self::Success, other) => other,
            (Self::AnalysisError, Self::IoError) => Self::IoError, // Prefer more specific errors
            (current, _) => current,
        }
    }
}

impl Termination for PipelineStatus {
    fn report(self) -> ExitCode {
        ExitCode::from(self as u8)
    }
}

pub(super) struct REPLFilesystem {
    base: FileImporter,
    stdin: String,
}

impl REPLFilesystem {
    pub(super) fn new(root: PathBuf) -> Self {
        Self {
            base: FileImporter::new(root),
            stdin: String::new(),
        }
    }
}

impl Filesystem for REPLFilesystem {
    fn read(&self, path: &Path) -> io::Result<String> {
        if path == Path::new("stdin") {
            return Ok(self.stdin.clone());
        }
        self.base.read(path)
    }
}

impl REPLFilesystem {
    pub(super) fn add(&mut self, source: &str) -> PathBuf {
        if !self.stdin.is_empty() {
            self.stdin.push('\n');
        }
        self.stdin.push_str(source);
        PathBuf::from("stdin")
    }
}
