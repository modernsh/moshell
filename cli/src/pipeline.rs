use analyzer::Filesystem;
use std::path::{Path, PathBuf};
use std::process::{ExitCode, Termination};

/// Represents the state of the pipeline.
#[repr(u8)]
#[derive(PartialEq, Debug, Clone, Copy, Eq)]
pub enum PipelineStatus {
    /// All the steps of the pipeline were executed successfully.
    Success,

    /// The execution of the generated bytecode exited with an error.
    ExecutionFailure,

    /// The parsing or the verification of a source failed.
    AnalysisError,

    /// A source could not be read because of an IO error.
    IoError,
}

impl PipelineStatus {
    /// Composes two statuses, by propagating error statuses.
    pub fn compose(self, other: Self) -> Self {
        match (self, other) {
            (Self::Success, other) => other,
            (Self::AnalysisError, Self::IoError) => Self::IoError, // Prefer more specific errors
            (current, _) => current,
        }
    }
}

impl Termination for PipelineStatus {
    fn report(self) -> ExitCode {
        ExitCode::from(self as u8)
    }
}

pub(super) struct RealFilesystem {
    pub(super) root: PathBuf,
}

impl Filesystem for RealFilesystem {
    fn read(&self, path: &Path) -> std::io::Result<String> {
        let mut path = self.root.join(path);
        path.set_extension("msh");
        std::fs::read_to_string(path)
    }
}
