use crate::bytecode::Opcode::*;
use enum_assoc::Assoc;
use std::mem::size_of;

/// Holds the currently generated bytecode.
///
/// While the bytecode simply consists of a sequence of bytes, this struct provides
/// methods to emit the correct instructions for multi-byte values.
#[derive(Default)]
pub struct Bytecode {
    pub bytes: Vec<u8>,
}

impl Bytecode {
    /// Returns the bytes count
    pub fn len(&self) -> usize {
        self.bytes.len()
    }

    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    pub fn emit_code(&mut self, code: Opcode) {
        self.bytes.push(code as u8);
    }

    pub fn emit_get_local(&mut self, identifier: u8) {
        self.emit_code(GetLocal);
        self.bytes.push(identifier);
    }

    pub fn emit_int(&mut self, constant: i64) {
        self.emit_code(PushInt);
        self.bytes.extend(constant.to_be_bytes());
    }

    pub fn emit_byte(&mut self, constant: u8) {
        self.emit_code(Opcode::PushByte);
        self.bytes.push(constant);
    }

    pub fn emit_float(&mut self, constant: f64) {
        self.emit_code(PushFloat);
        self.bytes.extend(constant.to_be_bytes());
    }

    pub fn emit_string_constant_ref(&mut self, constant_ref: usize) {
        self.emit_code(PushString);
        self.bytes.extend(constant_ref.to_be_bytes());
    }

    pub fn emit_instruction_pointer(&mut self, ip: usize) {
        self.bytes.extend(ip.to_be_bytes());
    }

    /// expands the byte vector to let a placeholder of the given size,
    /// returning the position of the placeholder in the vector
    pub fn create_placeholder(&mut self, placeholder_size: usize) -> usize {
        let pos = self.bytes.len();
        self.bytes.resize(pos + placeholder_size, 0);
        pos
    }

    /// Emits a jump instruction.
    ///
    /// It returns the index of the offset which is to be patched.
    #[must_use = "the jump address must be patched later"]
    pub fn emit_jump(&mut self, opcode: Opcode) -> usize {
        self.emit_code(opcode);
        self.create_placeholder(size_of::<usize>())
    }

    /// Takes the index of the jump offset to be patched as input, and patches
    /// it to point to the current instruction.
    pub fn patch_jump(&mut self, offset_idx: usize) {
        let ip = self.len();
        self.fill_in_ip(offset_idx, ip);
    }

    /// Emits a jump instruction to the given instruction pointer.
    pub fn jump_back_to(&mut self, start_idx: usize) {
        self.emit_code(Opcode::Jump);
        self.emit_instruction_pointer(start_idx);
    }

    pub fn extend(&mut self, bytecode: Bytecode) {
        self.bytes.extend(bytecode.bytes);
    }

    /// Fills an instruction pointer at given instruction pointer in the byte array
    pub fn fill_in_ip(&mut self, ip_dest: usize, ip: usize) {
        self.bytes[ip_dest..ip_dest + size_of::<usize>()].copy_from_slice(&ip.to_be_bytes())
    }

    /// Returns the current instruction pointer
    pub fn current_ip(&self) -> usize {
        self.len()
    }
}

/// see vm's `Opcode` enum for more details
#[repr(u8)]
#[derive(Assoc)]
#[func(pub fn mnemonic(&self) -> &'static str)]
pub enum Opcode {
    #[assoc(mnemonic = "pshi")]
    PushInt,
    #[assoc(mnemonic = "pshb")]
    PushByte,
    #[assoc(mnemonic = "pshf")]
    PushFloat,
    #[assoc(mnemonic = "pshs")]
    PushString,
    #[assoc(mnemonic = "get")]
    GetLocal,
    #[assoc(mnemonic = "set")]
    SetLocal,
    #[assoc(mnemonic = "spawn")]
    Spawn,

    #[assoc(mnemonic = "pop")]
    PopByte,
    #[assoc(mnemonic = "pop8")]
    PopQWord,

    #[assoc(mnemonic = "ifjmp")]
    IfJump,
    #[assoc(mnemonic = "ifnjmp")]
    IfNotJump,
    #[assoc(mnemonic = "jmp")]
    Jump,

    #[assoc(mnemonic = "i2s")]
    ConvertIntToStr,
    #[assoc(mnemonic = "f2s")]
    ConvertFloatToStr,
    #[assoc(mnemonic = "i2b")]
    ConvertIntToByte,
    #[assoc(mnemonic = "cct")]
    Concat,

    #[assoc(mnemonic = "bxor")]
    BXor,
    #[assoc(mnemonic = "iadd")]
    IntAdd,
    #[assoc(mnemonic = "isub")]
    IntSub,
    #[assoc(mnemonic = "imul")]
    IntMul,
    #[assoc(mnemonic = "idiv")]
    IntDiv,
    #[assoc(mnemonic = "imod")]
    IntMod,
}

impl TryFrom<u8> for Opcode {
    type Error = ();

    fn try_from(value: u8) -> Result<Self, Self::Error> {
        let opcode = match value {
            0 => PushInt,
            1 => PushFloat,
            2 => PushString,
            3 => GetLocal,
            4 => SetLocal,
            5 => Spawn,

            6 => PopByte,
            7 => PopQWord,

            8 => IfJump,
            9 => IfNotJump,
            10 => Jump,

            11 => ConvertIntToStr,
            12 => ConvertFloatToStr,
            _ => return Err(()),
        };
        Ok(opcode)
    }
}
