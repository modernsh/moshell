use std::mem::size_of;
use analyzer::types::hir::TypeId;
use analyzer::types::STRING;
use crate::r#type::{get_type_size, TypeSize};

#[derive(Debug, Clone, Copy)]
pub struct Placeholder {
    pos: u32,
}

/// Holds the currently generated bytecode.
///
/// While the bytecode simply consists of a sequence of instructions, this struct provides
/// support methods to emit basic bytecode
#[derive(Default)]
pub struct Bytecode {
    pub bytes: Vec<u8>,
}


impl Bytecode {
    /// Returns the instructions count
    pub fn len(&self) -> usize {
        self.bytes.len()
    }

    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    pub fn emit_int(&mut self, constant: i64) {
        self.bytes.extend(constant.to_be_bytes());
    }

    pub fn emit_byte(&mut self, constant: u8) {
        self.bytes.push(constant);
    }

    pub fn emit_u32(&mut self, constant: u32) {
        self.bytes.extend(constant.to_be_bytes());
    }

    pub fn emit_float(&mut self, constant: f64) {
        self.bytes.extend(constant.to_be_bytes());
    }

    pub fn emit_constant_ref(&mut self, constant: u32) {
        self.emit_u32(constant);
    }

    pub fn extend(&mut self, bytecode: Bytecode) {
        self.bytes.extend(bytecode.bytes);
    }

    /// Fills an instruction pointer at given instruction pointer in the byte array
    pub fn patch_u32_placeholder(&mut self, placeholder: Placeholder, value: u32) {
        let pos = placeholder.pos as usize;
        self.bytes[pos..pos + size_of::<u32>()].copy_from_slice(&value.to_be_bytes())
    }

    /// expands the byte vector to let a placeholder of the given size,
    /// returning the position of the placeholder in the vector
    pub fn emit_u32_placeholder(&mut self) -> Placeholder {
        let pos = self.bytes.len();
        self.bytes.resize(pos + size_of::<u32>(), 0);
        Placeholder { pos: pos as u32 }
    }
}

/// This structure is a [Bytecode] wrapper and is used
/// to emit bytecode instructions.
/// As each bytecode instruction set comes with an operand stack
/// this structure also evaluates the maximum operand stack size needed
pub struct Instructions<'a> {
    pub bytecode: &'a mut Bytecode,
    pub ip_offset: usize,

    pub push_offset: u32,
    pub max_operand_stack_size: u32,
    pub current_operand_stack_pos: u32,
}

impl<'a> Instructions<'a> {
    pub fn wrap(bytecode: &'a mut Bytecode) -> Self {
        Self {
            ip_offset: bytecode.len(),
            bytecode,
            push_offset: 0,
            max_operand_stack_size: 0,
            current_operand_stack_pos: 0,
        }
    }

    // prefer wrapper methods instead
    pub fn emit_code(&mut self, code: Opcode) {
        self.bytecode.emit_byte(code as u8)
    }

    pub fn emit_q_word_binary_op(&mut self, code: Opcode) {
        // this actually reduces operand stack by one qword as the two qwords gets pop
        // and the resulting qword gets pushed
        self.emit_bytes_and_reduce(code, &[], TypeSize::QWord);
    }

    pub fn emit_byte_binary_op(&mut self, code: Opcode) {
        // this actually reduces operand stack by one byte as the two bytes gets pop
        // and the resulting string gets pushed
        self.emit_bytes_and_reduce(code, &[], TypeSize::Byte);
    }

    pub fn emit_set_local(&mut self, identifier: u32, size: impl Into<TypeSize>) {
        let size = size.into();
        let opcode = match size {
            TypeSize::Byte => Opcode::SetByte,
            TypeSize::QWord => Opcode::SetQWord,
            TypeSize::Zero => panic!("set_local for value whose type is zero-sized")
        };
        self.emit_bytes_and_reduce(opcode, &identifier.to_be_bytes(), size);
    }

    pub fn emit_get_local(&mut self, identifier: u32, size: impl Into<TypeSize>) {
        let size = size.into();
        let opcode = match size {
            TypeSize::Byte => Opcode::GetByte,
            TypeSize::QWord => Opcode::GetQWord,
            TypeSize::Zero => panic!("get_local for value whose type is zero-sized")
        };
        self.emit_bytes_and_extend(opcode, &identifier.to_be_bytes(), size);
    }

    pub fn emit_push_int(&mut self, constant: i64) {
        self.emit_bytes_and_extend(Opcode::PushInt, &constant.to_be_bytes(), TypeSize::QWord);
    }

    pub fn emit_push_byte(&mut self, constant: u8) {
        self.emit_bytes_and_extend(Opcode::PushByte, &constant.to_be_bytes(), TypeSize::Byte);
    }

    pub fn emit_push_float(&mut self, constant: f64) {
        self.emit_bytes_and_extend(Opcode::PushFloat, &constant.to_be_bytes(), TypeSize::QWord);
    }

    pub fn emit_push_string_constant(&mut self, constant_ref: u32) {
        self.emit_bytes_and_extend(Opcode::PushString, &constant_ref.to_be_bytes(), TypeSize::QWord);
    }

    pub fn emit_pop_byte(&mut self) {
        self.emit_code(Opcode::PopByte);
        self.reduce_operands_size(TypeSize::Byte);
    }

    pub fn emit_pop_q_word(&mut self) {
        self.emit_code(Opcode::PopQWord);
        self.reduce_operands_size(TypeSize::QWord);
    }

    fn emit_bytes_and_extend(&mut self, opcode: Opcode, bytes: &[u8], size: TypeSize) {
        self.emit_code(opcode);
        self.bytecode.bytes.extend(bytes);
        self.extend_operands_size(size);
    }

    fn emit_bytes_and_reduce(&mut self, opcode: Opcode, bytes: &[u8], size: TypeSize) {
        self.emit_code(opcode);
        self.bytecode.bytes.extend(bytes);
        self.reduce_operands_size(size);
    }

    fn emit_instruction_pointer(&mut self, ip: u32) {
        self.bytecode.emit_u32(ip);
    }

    /// Emits a jump instruction.
    ///
    /// It returns the index of the offset which is to be patched.
    #[must_use = "the jump address must be patched later"]
    pub fn emit_jump(&mut self, opcode: Opcode) -> Placeholder {
        // if-jump operations pops the tested value from stack
        if opcode != Opcode::Jump {
            self.reduce_operands_size(TypeSize::Byte);
        }

        self.emit_code(opcode);

        self.bytecode.emit_u32_placeholder()
    }

    pub fn emit_spawn(&mut self, arg_count: u8) {
        self.emit_code(Opcode::Spawn);
        self.bytecode.emit_byte(arg_count);

        let arg_count = arg_count as u32;
        self.current_operand_stack_pos -= arg_count * get_type_size(STRING) as u32;
        self.push_offset -= arg_count;

        // the spawn opcode will push the process's exitcode in stack
        self.extend_operands_size(TypeSize::Byte)
    }

    pub fn emit_invoke(&mut self, arg_types: &[TypeId], return_type: TypeId, signature_idx: u32) {
        self.emit_code(Opcode::Invoke);
        self.bytecode.emit_constant_ref(signature_idx);

        for arg_type in arg_types {
            self.reduce_operands_size(*arg_type)
        }
        self.extend_operands_size(return_type);
    }

    /// Takes the index of the jump offset to be patched as input, and patches
    /// it to point to the current instruction.
    pub fn patch_jump(&mut self, offset_idx: Placeholder) {
        let ip = self.current_ip();
        self.bytecode.patch_u32_placeholder(offset_idx, ip);
    }

    /// Emits a jump instruction to the given instruction pointer.
    pub fn jump_back_to(&mut self, start_idx: u32) {
        self.emit_code(Opcode::Jump);
        self.emit_instruction_pointer(start_idx);
    }

    /// Returns the current instruction pointer
    pub fn current_ip(&self) -> u32 {
        (self.bytecode.len() - self.ip_offset) as u32
    }

    // prefer using method wrappers instead
    pub fn reduce_operands_size(&mut self, size: impl Into<TypeSize>) {
        if self.current_operand_stack_pos == 0 {
            panic!("operand stack size is empty")
        }

        let size = size.into() as u32;
        if self.current_operand_stack_pos < size {
            panic!("operand stack would get popped by {size} bytes where it's sized to {} at this point", self.current_operand_stack_pos)
        }

        self.push_offset -= 1;
        self.current_operand_stack_pos -= size;
    }

    // prefer using method wrappers instead
    pub fn extend_operands_size(&mut self, size: impl Into<TypeSize>) {
        self.current_operand_stack_pos += size.into() as u32;
        self.push_offset += 1;
        if self.current_operand_stack_pos > self.max_operand_stack_size {
            self.max_operand_stack_size = self.current_operand_stack_pos;
        }
    }
}

/// see vm's `Opcode` enum for more details
#[repr(u8)]
#[derive(Eq, PartialEq)]
pub enum Opcode {
    PushInt,
    PushByte,
    PushFloat,
    PushString,

    GetByte,
    SetByte,
    GetQWord,
    SetQWord,

    Spawn,
    Invoke,

    PopByte,
    PopQWord,

    IfJump,
    IfNotJump,
    Jump,

    ConvertIntToStr,
    ConvertFloatToStr,
    ConvertIntToByte,
    Concat,

    BXor,
    IntAdd,
    IntSub,
    IntMul,
    IntDiv,
    IntMod,
}
